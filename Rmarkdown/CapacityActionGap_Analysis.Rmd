---
title: "Unravelling the capacity-action gap in flood risk adaptation"
author: "Annika Schubert"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 8
    highlight: textmate
    theme: spacelab
    toc: yes
    toc_float: yes
  pdf_document:
    df_print: default
    fig_caption: yes
    fig_height: 4
    fig_width: 8
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This Rmarkdown contains paragraphs taken from

Schubert, A.; von Streit, A. & Garschagen, M. (2024): Unravelling the capacity-action gap in flood risk adaptation. In: Natural Hazards and Earth System Sciences Discussion [preprint], https://doi.org/10.5194/nhess-2024-121.


# Fit regression models

## Preparation

Load the necessary libraries

```{r libraries, results='markdown', eval=TRUE, message=FALSE, warning=FALSE}
library(here)                # for file referencing
library(haven)               # to work with the SPSS labbelled dataset
library(tidyverse)           # for data manipulation
library(mice)                # for data preparation
library(sandwich)            # cluster-robust standard error
library(marginaleffects)     # for AME calculation
library(DHARMa)              # residual diagnostics for generalized linear (mixed) models 
library(ggplot2)             # to create forest plots
library(cowplot)             # to arrange plots 
```

Load the imputed dataset, drop observations with missing information on adaptation action from the data (multiple imputation, then deletion approach) and do necessary recodings.

```{r dataprep, , echo=TRUE, cache = FALSE}
# load data and rename dataset
load(here::here("./data/tidy/KARE_imp_inck.RData"))
KARE_MI <- KARE_imp

### MID (multiple imputation, then deletion): 
# use Y to impute X, but drop obs with missing Y from the analysis (von Hippel 2007)

# create a long format dataset  
KARE_MI_long <- complete(KARE_MI, action = "long", include = TRUE)

# drop obs with NA on Y
KARE_MI_long <- subset(KARE_MI_long, !(IDS %in% KARE_MI_long$IDS[is.na(KARE_MI_long$numadmeas)]))

# recode R75 from imputed R75a (tenants - polyreg) and R75b (owners - logreg)
KARE_MI_long$R75 <- ifelse(KARE_MI_long$R7 == "Miete", KARE_MI_long$R75a, 
                           ifelse(KARE_MI_long$R75b == "Öffentliche Stellen (d.h. Bund, Länder oder Gemeinden)", 3, 1))
KARE_MI_long$R75 <- as_factor(KARE_MI_long$R75)

KARE_MI <- mice::as.mids(KARE_MI_long)
# n = 1,571 obs


### turn ordered factors into unordered to get pairwise comparisons 
# instead of polynomial contrasts
KARE_MI$data$R18 <- factor(KARE_MI$data$R18,
                           ordered = F)
KARE_MI$data$R80a_1 <- factor(KARE_MI$data$R80a_1,
                              ordered = F)
KARE_MI$data$R92 <- factor(KARE_MI$data$R92,
                           ordered = F)
KARE_MI$data$R104 <- factor(KARE_MI$data$R104,
                            ordered = F)
KARE_MI$data$Modus <- factor(KARE_MI$data$Modus,
                             ordered = F)

### change reference levels
KARE_MI$data$Modus <- relevel(KARE_MI$data$Modus, ref = "2")
KARE_MI$data$R92 <- relevel(KARE_MI$data$R92, ref = "unsure/short-term")
KARE_MI$data$R18 <- relevel(KARE_MI$data$R18, ref = "Überhaupt nicht wahrscheinlich")
KARE_MI$data$R4a5 <- relevel(KARE_MI$data$R4a5, ref = "none")
KARE_MI$data$R7 <- relevel(KARE_MI$data$R7, ref = "Miete")
KARE_MI$data$R80a_1 <- relevel(KARE_MI$data$R80a_1, ref = "Rather no/no")
```

## Logistic regression models

To explore whether a household adapts (yes/no), we run logistic regression models. For each model, assumptions were checked to ensure the validity and reliability of the results. To address the problem of unobserved heterogeneity in logistic and Poisson models, all effects are presented as average marginal effects (AME) (Mood 2010; Arel-Bundock et al. Forthcoming).


### Log reg full sample
```{r logfull, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp <- with(KARE_MI,
                     glm(admeas ~ R104 + R109 + R71 +    # generic capacity
                           R7 + R91 + R92 +
                           R90_1 + R90_5 +
                           R9 + R18 + R4a5 + R75 +       # flood-specific capacity
                           R63_6 + R80a_1 + R63_1 +
                           R63_3 + R63_2 + R63_4 +
                           R97 + R98 + R99 + R106 +      # CVs: gender, age, mig, hhsize
                           R69 + R70 +                   # CVs: house
                           Modus,                        # Survey design
                         family = binomial("logit")))
# calculate cluster-robust AME
marginal <- avg_slopes(glm_multiimp, vcov = ~town)
marginal$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                    23, 22, 24, 19, 30, 29, 5, 31, 4, 17, 18, 20, 11,
                    9, 10, 6, 8, 7, 25, 26, 27)
marginal <- marginal %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_log_AME <- c(NA, marginal$estimate)
se_log_AME <- c(NA, marginal$std.error)
p_log_AME <- c(NA, marginal$p.value)
print(marginal[order(marginal$order, decreasing = F),], nrows = 40, style = "tinytable") 


### Goodness of fit measures
#R^2
Nagelkerke_log_all <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_all_res <- c(DescTools::PseudoR2(glm_multiimp$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_all[i] <- Nagelkerke_log_all_res
}
median(Nagelkerke_log_all)

# BIC
BIC_log_all <- numeric(30)
for (i in 1:30) {
  BIC_log_all_res <- c(BIC(glm_multiimp$analyses[[i]]))
  BIC_log_all[i] <- BIC_log_all_res
}
median(BIC_log_all)
```

We checked the four logistic regression assumptions: 1) linearity, 2) independence, 3) no multicollinearity, and 4) exogeneity. Predictors are not affected by multicollinearity (variance inflation factor < 2). The violation of the independence assumptions is accounted for in two ways. Firstly, we estimate cluster-robust standard errors at the municipal level to account for the fact that respondents from the same municipality might be more similar to each other in terms of adaptive capacity and action. Secondly, the exogenous sample selection is removed by conditioning on the characteristics which are over- and underrepresented (e.g. age, income, education) (Wooldridge 2013, p. 325). To fulfil the exogeneity assumption and eliminate spurious correlations, additional variables such as house characteristics and survey mode are controlled for.

```{r logfullassumptions, echo=TRUE, cache = TRUE}
# 1) Linearity 
# not useful to plot the raw residuals, examine binned residual plots
arm::binnedplot(fitted(glm_multiimp$analyses[[7]]), 
                residuals(glm_multiimp$analyses[[7]], type = "response"), 
                nclass = NULL, 
                xlab = "Expected Values", 
                ylab = "Average residual", 
                main = "Binned residual plot", 
                cex.pts = 0.8, 
                col.pts = 1, 
                col.int = "gray")
KARE_data6 <- complete(KARE_MI, action=6)
arm::binnedplot(KARE_data6$R109, 
                residuals(glm_multiimp$analyses[[6]], type = "response"), 
                nclass = NULL, 
                xlab = "Expected Values", 
                ylab = "Average residual", 
                main = "Binned residual plot", 
                cex.pts = 0.8, 
                col.pts = 1, 
                col.int = "gray")

# 2) Independence 
# --> Respondents from the same town might be more similar to one another on the 
#     outcome measure, on average, than they are with respondents across towns
# plot residuals vs spatial variable
glm_data6 <- glm(data = KARE_data6,
                 admeas ~ R104 + R109 + R71 +    # generic capacity
                   R7 + R91 + R92 +
                   R90_1 + R90_5 +
                   R9 + R18 + R4a5 + R75 +       # flood-specific capacity
                   R63_6 + R80a_1 + R63_1 +
                   R63_3 + R63_2 + R63_4 +
                   R97 + R98 + R99 + R106 +      # CVs: gender, age, mig, hhsize
                   R69 + R70 +                   # CVs: house
                   Modus,                        # Survey design
                 family = binomial("logit"))                      
# by town
ggplot(data = data.frame(x = KARE_data6$town, y = glm_data6$residuals), aes(x = x, y = y)) +
  geom_boxplot() +
  coord_cartesian(ylim = c(-20, 20))
# some patterns --> use cluster-robust SEs
# maybe also due to small cluster sizes (e.g. 2, 5, 10 respondents)

# 3) No multicollinearity 
car::vif(glm_multiimp$analyses[[10]]) 
# GVIF (1/(2*Df) < 2 for all --> no multicollinearity

# 4) Exogeneity 
# --> all relevant CVs are included in the model
```

### Log reg property owners' sample
```{r logown, echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp_own <- with(KARE_MI,
                         glm(admeas ~ R104 + R109 + R71 +   # generic capacity
                               R91 + R92 +
                               R90_1 + R90_5 +
                               R9 + R18 + R4a5 + R75 +      # flood-specific capacity
                               R63_6 + R80a_1 + R63_1 +
                               R63_3 + R63_2 + R63_4 +
                               R97 + R98 + R99 + R106 +     # CVs: gender, age, mig, hhsize
                               R69 + R70 +                  # CVs: house
                               Modus,                       # Survey design
                             family = binomial("logit"),
                             subset = (R7 == "Eigentum")))

# calculate AME
marginal_own <- avg_slopes(glm_multiimp_own, vcov = ~town)
marginal_own$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                        23, 22, 24, 19, 30, 29, 31, 4, 18, 20, 11,
                        9, 10, 6, 8, 7, 25, 26, 27)
marginal_own <- marginal_own %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_log_AME_own <- c(NA, marginal_own$estimate)
se_log_AME_own <- c(NA, marginal_own$std.error)
p_log_AME_own <- c(NA, marginal_own$p.value)
print(marginal_own[order(marginal_own$order, decreasing = F),], nrows = 40, digits = 4, style = "tinytable") 


### Goodness of fit measures
#R^2
Nagelkerke_log_own <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_own_res <- c(DescTools::PseudoR2(glm_multiimp_own$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_own[i] <- Nagelkerke_log_own_res
}
median(Nagelkerke_log_own)

# BIC
BIC_log_own <- numeric(30)
for (i in 1:30) {
  BIC_log_own_res <- c(BIC(glm_multiimp_own$analyses[[i]]))
  BIC_log_own[i] <- BIC_log_own_res
}
median(BIC_log_own)
```

### Log reg tenants' sample
```{r logten, echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp_ten <- with(KARE_MI,
                         glm(admeas ~ R104 + R109 + R71 +        # generic capacity
                               R91 + R92 +
                               R90_1 + R90_5 +
                               R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                               R63_6 + R80a_1 + R63_1 +
                               R63_3 + R63_2 + R63_4 +
                               R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                               R69 + R70 +                # CVs: house
                               Modus,                     # Survey design
                             family = binomial("logit"),
                             subset = (R7 == "Miete")))

# calculate AME
marginal_ten <- avg_slopes(glm_multiimp_ten, vcov = ~town)
marginal_ten$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                        23, 22, 24, 19, 30, 29, 31, 4, 17, 18, 20, 11,
                        9, 10, 6, 8, 7, 25, 26, 27)
marginal_ten <- marginal_ten %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_log_AME_ten <- c(NA, marginal_ten$estimate)
se_log_AME_ten <- c(NA, marginal_ten$std.error)
p_log_AME_ten <- c(NA, marginal_ten$p.value)
print(marginal_ten[order(marginal_ten$order, decreasing = F),], nrows = 40, digits = 4, style = "tinytable") 


### Goodness of fit measures
#R^2
Nagelkerke_log_ten <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_ten_res <- c(DescTools::PseudoR2(glm_multiimp_ten$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_ten[i] <- Nagelkerke_log_ten_res
}
median(Nagelkerke_log_ten)

# BIC
BIC_log_ten <- numeric(30)
for (i in 1:30) {
  BIC_log_ten_res <- c(BIC(glm_multiimp_ten$analyses[[i]]))
  BIC_log_ten[i] <- BIC_log_ten_res
}
median(BIC_log_ten)
```

### Forest plot log reg
Create forest plots for the property owners' and tenants' results
```{r logplot, echo=TRUE, cache = TRUE, warning=FALSE, fig.height = 9}
# label variables
marginal_own <- marginal_own %>%
  mutate(label = c("Education - intermediate secondary", "Education - upper secondary", "Income", 
                   "Living area", "Duration of residence","Place attachment - medium-term", "Place attachment - long-term",
                   "Social network", "Social cohesion", "Future risk perception",
                   "Risk perception - not likely", "Risk perception - likely", "Risk perception - very likely",
                   "Previous experience - damage", "Previous experience - experience",  
                   "Main responsibility state", "Expecation in authorities", "Trust in authorities - yes", 
                   "Public protection is sufficient", "Self-efficacy", "Motivation", 
                   "Competing concerns",
                   NA, NA, NA,  NA, NA, NA, NA, NA, NA ), 
         .after = term)

marginal_ten <- marginal_ten %>%
  mutate(label = c("Education - intermediate secondary", "Education - upper secondary", "Income", 
                   "Living area", "Duration of residence","Place attachment - medium-term", "Place attachment - long-term",
                   "Social network", "Social cohesion", "Future risk perception",
                   "Risk perception - not likely", "Risk perception - likely", "Risk perception - very likely",
                   "Previous experience - damage", "Previous experience - experience", "Main responsibility landlord",  
                   "Main responsibility state", "Expecation in authorities", "Trust in authorities - yes", 
                   "Public protection is sufficient", "Self-efficacy", "Motivation", 
                   "Competing concerns",
                   NA, NA, NA,  NA, NA, NA, NA, NA, NA ), 
         .after = term)

# drop control variables
marginal_own2 <- marginal_own %>% drop_na(label) 
marginal_ten2 <- marginal_ten %>% drop_na(label)

# merge results owners & tenants into one dataframe
marginal_own_ten <- merge(marginal_ten2, marginal_own2, by = "label", all = T)
marginal_own_ten <- marginal_own_ten[order(marginal_own_ten$estimate.y, decreasing = TRUE),]
# for plotting: add value for missing landlord which is not within plotted boundaries
marginal_own_ten$estimate.y[is.na(marginal_own_ten$estimate.y)] <- -2


# change colors 
colors_log <- c("#588BAE", "#588BAE", "#588BAE", "#588BAE","#588BAE", 
                "black", "#588BAE", "black", "black", "black",
                "#588BAE", "#588BAE", "black", "black", "#588BAE",
                "black", "black", "black",  "#588BAE","#588BAE",
                "#588BAE", "#588BAE", "#588BAE")
colors_log_label <- c("#588BAE", "#588BAE", "#588BAE", "#588BAE", "#588BAE",
                      "black", "black", "black", "#588BAE", "black", 
                      "black", "#588BAE", "#588BAE", "black", "black", 
                      "black", "#588BAE", "black", "#588BAE", "#588BAE", 
                      "#588BAE", "#588BAE","#588BAE")
# add source label
lab_cap <- expression(paste("Source: own calculation, data from KARE household survey 2022 (",
                            n[Owners], " = 1,157; ", n[Tenants], " = 414)"))

# plot owners
log_own <- ggplot(marginal_own_ten, aes(y = reorder(label, estimate.y), x = estimate.y, xmin = conf.low.y, xmax = conf.high.y)) +
  geom_vline(xintercept = 0, linetype="solid", 
             color = "#758DA3", size=0.5) +
  geom_pointrange(color = colors_log) +
  labs(x ="AME", y = "",
       title = "Owners", caption = " ") + 
  xlim(-0.3, 0.6) + 
  theme_minimal() +
  theme(axis.text.y = element_text(colour = colors_log_label, size = 14),
        plot.title = element_text(size = 15, hjust = 0.5, face = "bold"))

# plot tenants
log_ten <- ggplot(marginal_own_ten, aes(y = reorder(label, estimate.y), x = estimate.x, xmin = conf.low.x, xmax = conf.high.x)) +
  geom_vline(xintercept = 0, linetype="solid", 
             color = "#758DA3", size=0.5) +
  geom_pointrange(color = colors_log) + 
  labs(x ="AME", y = "",
       title = "Tenants", caption = lab_cap) + 
  xlim(-0.3, 0.6) + 
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        plot.title = element_text(size = 15, hjust = 0.5, face = "bold"))

# create title
title_log <- ggdraw() + 
  draw_label(
    "Effect sizes of adaptive capacity indicators explaing household adaptation (yes/no)",
    fontface = 'bold', size = 16,x = 0, hjust = 0)  +
  theme(plot.margin = margin(0, 0, 0, 7))


plot_log <- plot_grid(log_own, log_ten, rel_widths = c(2.1,0.9))
plot_grid(title_log, plot_log, ncol = 1, rel_heights = c(0.1, 1))
```


## Poisson regression models

To explore which adaptive capacity indicators drive the number of implemented pluvial flood adaptation measures, we use Poisson regression models. Linear regression led to similar findings; however models suffered from heteroscedasticity. Given thar the number of implemented measures is discrete count data, we decided to rather estimate Poisson models. We checked the assumptions for each model seperately, all models were neither overdispersed nor zero-inflated. The effects are presented as average marginal effects (AME) (Mood 2010; Arel-Bundock et al. Forthcoming).

### Poisson reg full sample
```{r poisfull, echo=TRUE, cache = TRUE, warning=FALSE}
# fit poisson regression to each imputed data set 
pois_multiimp <- with(KARE_MI, 
                      glm(numadmeas ~ R104 + R109 + R71 +        # generic capacity
                            R7 + R91 + R92 +
                            R90_1 + R90_5 +
                            R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                            R63_6 + R80a_1 + R63_1 +
                            R63_3 + R63_2 + R63_4 +
                            R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                            R69 + R70 +                # CVs: house
                            Modus,                     # Survey design
                          family = 'poisson'))

# calculate cluster-robust AME
marginal_pois <- avg_slopes(pois_multiimp, vcov = ~town)
marginal_pois$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                         23, 22, 24, 19, 30, 29, 5, 31, 4, 17, 18, 20, 11,
                         9, 10, 6, 8, 7, 25, 26, 27) 
marginal_pois <- marginal_pois %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_pois_AME <- c(NA, marginal_pois$estimate)
se_pois_AME <- c(NA, marginal_pois$std.error)
p_pois_AME <- c(NA, marginal_pois$p.value)
print(marginal_pois[order(marginal_pois$order, decreasing = F),], nrows = 40, style = "tinytable") 


## Goodness of fit measures
# R^2
Nagelkerke_pois_all <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_all_res <- c(DescTools::PseudoR2(pois_multiimp$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_all[i] <- Nagelkerke_pois_all_res
}
median(Nagelkerke_pois_all)

# BIC
BIC_pois_all <- numeric(30)
for (i in 1:30) {
  BIC_pois_all_res <- c(BIC(pois_multiimp$analyses[[i]]))
  BIC_pois_all[i] <- BIC_pois_all_res
}
median(BIC_pois_all)
```

Check if assumptions are met
```{r poisfullassumptions, echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp <- simulateResiduals(pois_multiimp$analyses[[5]], nSim = 1000) 

# under- and overdispersion --> not sign.
# ratio close to 1 --> Poisson model fits well to the data, no over-/underdispersion
testDispersion(sim_fmp)

# Zero inflation --> not sign.
testZeroInflation(sim_fmp)

# Heteroscedasticity --> not sign.
testQuantiles(sim_fmp)

# KS test for correct distribution of residuals --> not sign.
testUniformity(sim_fmp)

# test if outliers are a concern, bootstrap for integer-valued distributions --> not sign.
testOutliers(sim_fmp, type = "bootstrap")
```

### Poisson reg owners' sample
```{r poisown, echo=TRUE, cache = TRUE, warning=FALSE}
# fit poisson regression to each imputed data set 
pois_multiimp_own <- with(KARE_MI, 
                          glm(numadmeas ~ R104 + R109 + R71 +        # generic capacity
                                R91 + R92 +
                                R90_1 + R90_5 +
                                R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                                R63_6 + R80a_1 + R63_1 +
                                R63_3 + R63_2 + R63_4 +
                                R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                                R69 + R70 +                # CVs: house
                                Modus,                     # Survey design
                              family = 'poisson',
                              subset = (R7 == "Eigentum")))

# calculate cluster-robust AME
marginal_pois_own <- avg_slopes(pois_multiimp_own, vcov = ~town)
marginal_pois_own$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                             23, 22, 24, 19, 30, 29, 31, 4, 18, 20, 11,
                             9, 10, 6, 8, 7, 25, 26, 27)
marginal_pois_own <- marginal_pois_own %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_pois_AME_own <- c(NA, marginal_pois_own$estimate)
se_pois_AME_own <- c(NA, marginal_pois_own$std.error)
p_pois_AME_own <- c(NA, marginal_pois_own$p.value)
print(marginal_pois_own[order(marginal_pois_own$order, decreasing = F),], nrows = 40, style = "tinytable") 


## Goodness of fit measures
# R^2
# R^2
Nagelkerke_pois_own <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_own_res <- c(DescTools::PseudoR2(pois_multiimp_own$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_own[i] <- Nagelkerke_pois_own_res
}
median(Nagelkerke_pois_own)

# BIC
BIC_pois_own <- numeric(30)
for (i in 1:30) {
  BIC_pois_own_res <- c(BIC(pois_multiimp_own$analyses[[i]]))
  BIC_pois_own[i] <- BIC_pois_own_res
}
median(BIC_pois_own)
```

Check if assumptions are met
```{r poisownassumptions, echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp_own <- simulateResiduals(pois_multiimp_own$analyses[[16]], nSim = 1000) 

# under- and overdispersion --> not sign.
# ratio close to 1 --> Poisson model fits well to the data, no over-/underdispersion
testDispersion(sim_fmp_own)

# Zero inflation --> not sign.
testZeroInflation(sim_fmp_own)

# Heteroscedasticity --> not sign.
testQuantiles(sim_fmp_own)

# KS test for correct distribution of residuals --> not sign.
testUniformity(sim_fmp_own)

# test if outliers are a concern, bootstrap for integer-valued distributions --> not sign.
testOutliers(sim_fmp_own, type = "bootstrap")
```

### Poisson reg tenants' sample
```{r poisten, echo=TRUE, cache = TRUE, warning=FALSE}
# fit poisson regression to each imputed data set 
pois_multiimp_ten <- with(KARE_MI, 
                          glm(numadmeas ~ R104 + R109 + R71 +        # generic capacity
                                R91 + R92 +
                                R90_1 + R90_5 +
                                R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                                R63_6 + R80a_1 + R63_1 +
                                R63_3 + R63_2 + R63_4 +
                                R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                                R69 + R70 +                # CVs: house
                                Modus,                     # Survey design
                              family = 'poisson',
                              subset = (R7 == "Miete")))

# calculate cluster-robust AME
marginal_pois_ten <- avg_slopes(pois_multiimp_ten, vcov = ~town)
marginal_pois_ten$order <- c(32, 33, 1, 2, 28, 3, 12, 13, 14, 15, 16, 21, 
                             23, 22, 24, 19, 30, 29, 31, 4, 17, 18, 20, 11,
                             9, 10, 6, 8, 7, 25, 26, 27)
marginal_pois_ten <- marginal_pois_ten %>%
        mutate(across(c(3:5, 10:13), round, 4))
b_pois_AME_ten <- c(NA, marginal_pois_ten$estimate)
se_pois_AME_ten <- c(NA, marginal_pois_ten$std.error)
p_pois_AME_ten <- c(NA, marginal_pois_ten$p.value)
print(marginal_pois_ten[order(marginal_pois_ten$order, decreasing = F),], nrows = 40, style = "tinytable") 


## Goodness of fit measures
# R^2
# R^2
# R^2
Nagelkerke_pois_ten <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_ten_res <- c(DescTools::PseudoR2(pois_multiimp_ten$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_ten[i] <- Nagelkerke_pois_ten_res
}
median(Nagelkerke_pois_ten)

# BIC
BIC_pois_ten <- numeric(30)
for (i in 1:30) {
  BIC_pois_ten_res <- c(BIC(pois_multiimp_ten$analyses[[i]]))
  BIC_pois_ten[i] <- BIC_pois_ten_res
}
median(BIC_pois_ten)
```

Check if assumptions are met
```{r poistenassumptions, echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp_ten <- simulateResiduals(pois_multiimp_ten$analyses[[16]], nSim = 1000) 

# under- and overdispersion --> not sign.
# ratio close to 1 --> Poisson model fits well to the data, no over-/underdispersion
testDispersion(sim_fmp_ten)

# Zero inflation --> not sign.
testZeroInflation(sim_fmp_ten)

# Heteroscedasticity --> not sign.
testQuantiles(sim_fmp_ten)

# KS test for correct distribution of residuals --> not sign.
testUniformity(sim_fmp_ten)

# test if outliers are a concern, bootstrap for integer-valued distributions --> not sign.
testOutliers(sim_fmp_ten, type = "bootstrap")
```

### Forest plot Poisson reg

Create forest plots for the property owners' and tenants' results
```{r poisplot, echo=TRUE, cache = TRUE, warning=FALSE, fig.height = 9}

# label variables
marginal_pois_own <- marginal_pois_own %>%
  mutate(label = c("Education - intermediate secondary", "Education - upper secondary", "Income", 
                   "Living area", "Duration of residence","Place attachment - medium-term", "Place attachment - long-term",
                   "Social network", "Social cohesion", "Future risk perception",
                   "Risk perception - not likely", "Risk perception - likely", "Risk perception - very likely",
                   "Previous experience - damage", "Previous experience - experience",  
                   "Main responsibility state", "Expecation in authorities", "Trust in authorities - yes", 
                   "Public protection is sufficient", "Self-efficacy", "Motivation", 
                   "Competing concerns",
                   NA, NA, NA,  NA, NA, NA, NA, NA, NA ), 
         .after = term)

marginal_pois_ten <- marginal_pois_ten %>%
  mutate(label = c("Education - intermediate secondary", "Education - upper secondary", "Income", 
                   "Living area", "Duration of residence","Place attachment - medium-term", "Place attachment - long-term",
                   "Social network", "Social cohesion", "Future risk perception",
                   "Risk perception - not likely", "Risk perception - likely", "Risk perception - very likely",
                   "Previous experience - damage", "Previous experience - experience", "Main responsibility landlord",  
                   "Main responsibility state", "Expecation in authorities", "Trust in authorities - yes", 
                   "Public protection is sufficient", "Self-efficacy", "Motivation", 
                   "Competing concerns",
                   NA, NA, NA,  NA, NA, NA, NA, NA, NA ), 
         .after = term)

#drop control variables
marginal_pois_own2 <- marginal_pois_own %>% drop_na(label) 
marginal_pois_ten2 <- marginal_pois_ten %>% drop_na(label)

# merge results owners & tenants into one dataframe
marginal_pois_own_ten <- merge(marginal_pois_ten2, marginal_pois_own2, by = "label", all = T)
marginal_pois_own_ten <- marginal_pois_own_ten[order(marginal_pois_own_ten$estimate.y, decreasing = TRUE),]
# for plotting: add value for missing landlord which is not within plotted boundaries
marginal_pois_own_ten$estimate.y[is.na(marginal_pois_own_ten$estimate.y)] <- -2


# change colors 
colors_pois <- c("#588BAE", "#588BAE", "#588BAE", "black", "#588BAE",
                 "black", "#588BAE", "black", "#588BAE", "black", 
                 "#588BAE", "#588BAE", "black", "black", "#588BAE", 
                 "black", "black", "#588BAE", "black", "#588BAE", 
                 "#588BAE", "#588BAE", "#588BAE")
colors_pois_label <- c("#588BAE", "#588BAE", "#588BAE", "#588BAE", "black", 
                       "#588BAE", "black", "black", "#588BAE", "black", 
                       "black", "#588BAE", "#588BAE", "black", "#588BAE", 
                       "black", "#588BAE", "black", "#588BAE", "black",
                       "#588BAE", "#588BAE", "#588BAE")

lab_cap <- expression(paste("Source: own calculation, data from KARE household survey 2022 (",
                            n[Owners], " = 1,157; ", n[Tenants], " = 414)"))


pois_own <- ggplot(marginal_pois_own_ten, aes(y = reorder(label, estimate.y), x = estimate.y, xmin = conf.low.y, xmax = conf.high.y)) +
  geom_vline(xintercept = 0, linetype="solid", 
             color = "#758DA3", size=0.5) +
  geom_pointrange(color = colors_pois) + 
  labs(x ="AME", y = "",
       title = "Owners", caption = " ") + 
  xlim(-0.6, 1.3) + 
  theme_minimal() +
  theme(axis.text.y = element_text(colour = colors_pois_label, size = 14),
        plot.title = element_text(size = 15, hjust = 0.5, face = "bold"))


pois_ten <- ggplot(marginal_pois_own_ten, aes(y = reorder(label, estimate.y), x = estimate.x, xmin = conf.low.x, xmax = conf.high.x)) +
  geom_vline(xintercept = 0, linetype="solid", 
             color = "#758DA3", size=0.5) +
  geom_pointrange(color = colors_pois) + 
  labs(x ="AME", y = "",
       title = "Tenants", caption = lab_cap) + 
  xlim(-0.6, 1.3) + 
  theme_minimal() +
  theme(axis.text.y = element_blank(),
        plot.title = element_text(size = 15, hjust = 0.5, face = "bold"))

title_pois <- ggdraw() + 
  draw_label("Effect sizes of adaptive capacity indicators explaing the number of implemented pluvial flood adaptation measures",
    fontface = 'bold', size = 16, x = 0, hjust = 0)  +
  theme( plot.margin = margin(0, 0, 0, 7))


plot_pois <- plot_grid(pois_own, pois_ten, rel_widths = c(2.1,0.9))
plot_grid(title_pois, plot_pois,  ncol = 1, rel_heights = c(0.1, 1))
```


## Robustness check: log(Income) + income groups

We estimated additional models to test the robustness of the income effect. Robustness checks for the income effect were necessary, as household net income was originally collected as binned data, but bin midpoints were used in the models to approximate income. Research has proven that this method works well for mid-income classes (Stauder & Hüning 2004); however, there are deviations in the tails due to small numbers of observations and broader bins. 
Changes: 

* log(R109) to compress the range of higher incomes and make the distribution more symmetric.
* account for differences between income groups: 

  1) low < 1300 € equalised disposable net income,

  2) middle between 1300 € and 4000 €, and 

  3) high > 4000€


```{r datapreprobcheck, echo=TRUE, cache = FALSE}
# load imputed dataset
load(here::here("./data/tidy/KARE_imp_richlog.RData"))
KARE_MI <- KARE_imp

### MID (multiple imputation, then deletion): 
# use Y to impute X, but drop obs with missing Y from the analysis (von Hippel 2007)

# create a long format dataset  
KARE_MI_long <- complete(KARE_MI, action = "long", include = TRUE)

# drop obs with NA on Y
KARE_MI_long <- subset(KARE_MI_long, !(IDS %in% KARE_MI_long$IDS[is.na(KARE_MI_long$numadmeas)]))

# recode R75 from imputed R75a (tenants - polyreg) and R75b (owners - logreg)
KARE_MI_long$R75 <- ifelse(KARE_MI_long$R7 == "Miete", KARE_MI_long$R75a, 
                           ifelse(KARE_MI_long$R75b == "Öffentliche Stellen (d.h. Bund, Länder oder Gemeinden)", 3, 1))
KARE_MI_long$R75 <- as_factor(KARE_MI_long$R75)

KARE_MI <- mice::as.mids(KARE_MI_long)
# n = 1,571 obs

### turn ordered factors into unordered to get pairwise comparisons 
# instead of polynomial contrasts
KARE_MI$data$R18 <- factor(KARE_MI$data$R18,
                           ordered = F)
KARE_MI$data$R80a_1 <- factor(KARE_MI$data$R80a_1,
                              ordered = F)
KARE_MI$data$R92 <- factor(KARE_MI$data$R92,
                           ordered = F)
KARE_MI$data$R104 <- factor(KARE_MI$data$R104,
                            ordered = F)
KARE_MI$data$Modus <- factor(KARE_MI$data$Modus,
                             ordered = F)

### change reference levels
KARE_MI$data$Modus <- relevel(KARE_MI$data$Modus, ref = "2")
KARE_MI$data$R92 <- relevel(KARE_MI$data$R92, ref = "unsure/short-term")
KARE_MI$data$R18 <- relevel(KARE_MI$data$R18, ref = "Überhaupt nicht wahrscheinlich")
KARE_MI$data$R4a5 <- relevel(KARE_MI$data$R4a5, ref = "none")
KARE_MI$data$R7 <- relevel(KARE_MI$data$R7, ref = "Miete")
KARE_MI$data$R80a_1 <- relevel(KARE_MI$data$R80a_1, ref = "Rather no/no")
KARE_MI$data$rich <- relevel(KARE_MI$data$rich, ref = "middle")
```


```{r datapreplogR109, echo=FALSE, cache = FALSE}
# create a long format dataset  
KARE_MI_long <- complete(KARE_MI, action = "long", include = TRUE)

### Einschub nur hier im 0-full-script:
KARE_MI_long$logR109 <- KARE_MI_long$R109

KARE_MI <- mice::as.mids(KARE_MI_long)
# n = 1,571 obs
```

### Logistic regression models

After preparing the data, run the logistic regression models with cluster-robust standard errors for
1) the full sample

```{r roblogfull, echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp <- with(KARE_MI,
                     glm(admeas ~ R104 + logR109 + rich + R71 +        # generic capacity
                           R7 + R91 + R92 +
                           R90_1 + R90_5 +
                           R9 + R18 + R4a5 + R75 +                     # flood-specific capacity
                           R63_6 + R80a_1 + R63_1 +
                           R63_3 + R63_2 + R63_4 +
                           R97 + R98 + R99 + R106 +                    # CVs: gender, age, mig, hhsize
                           R69 + R70 +                                 # CVs: house
                           Modus,                                      # Survey design
                         family = binomial("logit")))

# calculate AME
marginal <- avg_slopes(glm_multiimp, vcov = ~town)
marginal$order <- c(34, 35, 1, 2, 30, 14, 15, 16, 17, 18, 23, 
                    25, 24, 26, 21, 32, 31, 7, 33, 6, 19, 20, 22, 13, 
                    11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5)  
marginal <- marginal %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal[order(marginal$order, decreasing = F),], nrows = 40, style = "tinytable") 

### Goodness of fit measures
#R^2
Nagelkerke_log_all <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_all_res <- c(DescTools::PseudoR2(glm_multiimp$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_all[i] <- Nagelkerke_log_all_res
}
median(Nagelkerke_log_all)

# BIC
BIC_log_all <- numeric(30)
for (i in 1:30) {
  BIC_log_all_res <- c(BIC(glm_multiimp$analyses[[i]]))
  BIC_log_all[i] <- BIC_log_all_res
}
median(BIC_log_all)
```

We checked the four logistic regression assumptions: 1) linearity, 2) independence, 3) no multicollinearity, and 4) exogeneity. Tests revealed no problems.
```{r roblogfullassumptions, , echo=TRUE, cache = TRUE}
# 1) Linearity 
plot(glm_multiimp$analyses[[7]], 1)
# not useful to plot the raw residuals, examine binned residual plots
arm::binnedplot(fitted(glm_multiimp$analyses[[7]]), 
                residuals(glm_multiimp$analyses[[7]], type = "response"), 
                nclass = NULL, 
                xlab = "Expected Values", 
                ylab = "Average residual", 
                main = "Binned residual plot", 
                cex.pts = 0.8, 
                col.pts = 1, 
                col.int = "gray")
KARE_data6 <- complete(KARE_MI, action=6)
arm::binnedplot(KARE_data6$logR109, 
                residuals(glm_multiimp$analyses[[6]], type = "response"), 
                nclass = NULL, 
                xlab = "Expected Values", 
                ylab = "Average residual", 
                main = "Binned residual plot", 
                cex.pts = 0.8, 
                col.pts = 1, 
                col.int = "gray")

# 2) Independence 
# --> Respondents from the same town might be more similar to one another on the 
#     outcome measure, on average, than they are with respondents across towns
# plot residuals vs spatial variable
glm_data6 <- glm(data = KARE_data6,
                 admeas ~ R104 + logR109 + rich + R71 +        # generic capacity
                   R7 + R91 + R92 +
                   R90_1 + R90_5 +
                   R9 + R18 + R4a5 + R75 +                    # flood-specific capacity
                   R63_6 + R80a_1 + R63_1 +
                   R63_3 + R63_2 + R63_4 +
                   R97 + R98 + R99 + R106 +                   # CVs: gender, age, mig, hhsize
                   R69 + R70 +                                # CVs: house
                   Modus,                                     # Survey design
                 family = binomial("logit"))                                  
ggplot(data = data.frame(x = KARE_data6$town, y = glm_data6$residuals), aes(x = x, y = y)) +
  geom_boxplot() +
  coord_cartesian(ylim = c(-20, 20))
# some patterns --> use cluster-robust SEs
# maybe also due to small cluster sizes (e.g. 2, 5, 10 respondents)

# 3) No multicollinearity 
car::vif(glm_multiimp$analyses[[10]]) 
# GVIF to the power of 1/2df makes the value of the GVIF comparable across 
# different number of parameters --> 
# GVIF (1/(2*Df) < 2.1 for all --> no multicollinearity

# 4) Exogeneity 
# --> all relevant CVs are included in the model
```

2) the property owners' sample
```{r roblogown, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp_own <- with(KARE_MI,
                         glm(admeas ~ R104 + logR109 + rich + R71 +   # generic capacity
                               R91 + R92 +
                               R90_1 + R90_5 +
                               R9 + R18 + R4a5 + R75 +      # flood-specific capacity
                               R63_6 + R80a_1 + R63_1 +
                               R63_3 + R63_2 + R63_4 +
                               R97 + R98 + R99 + R106 +     # CVs: gender, age, mig, hhsize
                               R69 + R70 +                  # CVs: house
                               Modus,                       # Survey design
                             family = binomial("logit"),
                             subset = (R7 == "Eigentum")))

# calculate AME
marginal_own <- avg_slopes(glm_multiimp_own, vcov = ~town)
marginal_own$order <- c(34, 35, 1, 2, 30, 14, 15, 16, 17, 18, 23, 
                        25, 24, 26, 21, 32, 31, 33, 6, 20, 22, 13, 
                        11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5) 
marginal_own <- marginal_own %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal_own[order(marginal_own$order, decreasing = F),], nrows = 40, style = "tinytable") 


### Goodness of fit measures
#R^2
Nagelkerke_log_own <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_own_res <- c(DescTools::PseudoR2(glm_multiimp_own$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_own[i] <- Nagelkerke_log_own_res
}
median(Nagelkerke_log_own)

# BIC
BIC_log_own <- numeric(30)
for (i in 1:30) {
  BIC_log_own_res <- c(BIC(glm_multiimp_own$analyses[[i]]))
  BIC_log_own[i] <- BIC_log_own_res
}
median(BIC_log_own)
```

3) the tenants' sample
```{r roblogten, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
glm_multiimp_ten <- with(KARE_MI,
                         glm(admeas ~ R104 + logR109 + rich + R71 +       # generic capacity
                               R91 + R92 +
                               R90_1 + R90_5 +
                               R9 + R18 + R4a5 + R75 +                    # flood-specific capacity
                               R63_6 + R80a_1 + R63_1 +
                               R63_3 + R63_2 + R63_4 +
                               R97 + R98 + R99 + R106 +                   # CVs: gender, age, mig, hhsize
                               R69 + R70 +                                # CVs: house
                               Modus,                                     # Survey design
                             family = binomial("logit"),
                             subset = (R7 == "Miete")))

# calculate AME
marginal_ten <- avg_slopes(glm_multiimp_ten, vcov = ~town)
marginal_ten$order <- c(34, 35, 1, 2, 30, 14, 15, 16, 17, 18, 23, 
                        25, 24, 26, 21, 32, 31, 33, 6, 19, 20, 22, 13, 
                        11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5) 
marginal_ten <- marginal_ten %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal_ten[order(marginal_ten$order, decreasing = F),], nrows = 40, style = "tinytable") 

### Goodness of fit measures
#R^2
Nagelkerke_log_ten <- numeric(30)
for (i in 1:30) {
  Nagelkerke_log_ten_res <- c(DescTools::PseudoR2(glm_multiimp_ten$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_log_ten[i] <- Nagelkerke_log_ten_res
}
median(Nagelkerke_log_ten)

# BIC
BIC_log_ten <- numeric(30)
for (i in 1:30) {
  BIC_log_ten_res <- c(BIC(glm_multiimp_ten$analyses[[i]]))
  BIC_log_ten[i] <- BIC_log_ten_res
}
median(BIC_log_ten)
```


### Poisson regression models

Poisson regression models with cluster-robust standard errors for
1) the full sample

```{r robpoisfull, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit logistic regression to each imputed data set 
pois_multiimp <- with(KARE_MI, 
                      glm(numadmeas ~ R104 + logR109 + rich + R71 +        # generic capacity
                            R7 + R91 + R92 +
                            R90_1 + R90_5 +
                            R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                            R63_6 + R80a_1 + R63_1 +
                            R63_3 + R63_2 + R63_4 +
                            R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                            R69 + R70 +                # CVs: house
                            Modus,                     # Survey design
                          family = 'poisson'))

# calculate AME
marginal_pois <- avg_slopes(pois_multiimp, vcov = ~town)
marginal_pois$order <- c(34, 35, 1, 2, 30,14, 15, 16, 17, 18, 23, 
                         25, 24, 26, 21, 32, 31, 7, 33, 6, 19, 20, 22, 13, 
                         11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5)
marginal_pois <- marginal_pois %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal_pois[order(marginal_pois$order, decreasing = F),], nrows = 40, style = "tinytable") 

### Goodness of fit measures
# R^2
Nagelkerke_pois_all <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_all_res <- c(DescTools::PseudoR2(pois_multiimp$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_all[i] <- Nagelkerke_pois_all_res
}
median(Nagelkerke_pois_all)

# BIC
BIC_pois_all <- numeric(30)
for (i in 1:30) {
  BIC_pois_all_res <- c(BIC(pois_multiimp$analyses[[i]]))
  BIC_pois_all[i] <- BIC_pois_all_res
}
median(BIC_pois_all)
```

Check if assumptions are met
```{r robpoisfullassumptions, , echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp <- simulateResiduals(pois_multiimp$analyses[[5]], nSim = 1000) 

# under- and overdispersion --> not sign.
# ratio close to 1 --> Poisson model fits well to the data, no over-/underdispersion
testDispersion(sim_fmp)


# Zero inflation --> not sign.
testZeroInflation(sim_fmp)

# Heteroscedasticity --> not sign.
testQuantiles(sim_fmp)

# KS test for correct distribution of residuals --> not sign.
testUniformity(sim_fmp)

# test if outliers are a concern, bootstrap for integer-valued distributions --> not sign.
testOutliers(sim_fmp, type = "bootstrap")
```

2) the property owners' sample
```{r robpoisown, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit poisson regression to each imputed data set 
pois_multiimp_own <- with(KARE_MI, 
                          glm(numadmeas ~ R104 + logR109 + rich + R71 +        # generic capacity
                                R91 + R92 +
                                R90_1 + R90_5 +
                                R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                                R63_6 + R80a_1 + R63_1 +
                                R63_3 + R63_2 + R63_4 +
                                R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                                R69 + R70 +                # CVs: house
                                Modus,                     # Survey design
                              family = 'poisson',
                              subset = (R7 == "Eigentum")))

# calculate cluster-robust AME
marginal_pois_own <- avg_slopes(pois_multiimp_own, vcov = ~town)
marginal_pois_own$order <- c(34, 35, 1, 2, 30, 14, 15, 16, 17, 18, 23, 
                             25, 24, 26, 21, 32, 31, 33, 6, 20, 22, 13, 
                             11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5) 
marginal_pois_own <- marginal_pois_own %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal_pois_own[order(marginal_pois_own$order, decreasing = F),], nrows = 40, style = "tinytable") 


### Goodness of fit measures
# R^2
Nagelkerke_pois_own <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_own_res <- c(DescTools::PseudoR2(pois_multiimp_own$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_own[i] <- Nagelkerke_pois_own_res
}
median(Nagelkerke_pois_own)

# BIC
BIC_pois_own <- numeric(30)
for (i in 1:30) {
  BIC_pois_own_res <- c(BIC(pois_multiimp_own$analyses[[i]]))
  BIC_pois_own[i] <- BIC_pois_own_res
}
median(BIC_pois_own)
```

Check if logistic regression assumptions are met
```{r robpoisownassumptions, , echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp_own <- simulateResiduals(pois_multiimp_own$analyses[[16]], nSim = 1000) 

# under- and overdispersion --> not. sign.
testDispersion(sim_fmp_own)

# Zero inflation --> not. sign.
testZeroInflation(sim_fmp_own)

# Heteroscedasticity --> not. sign.
testQuantiles(sim_fmp_own)

# KS test for correct distribution of residuals --> not. sign.
testUniformity(sim_fmp_own)

# test if outliers are a concern, bootstrap for integer-valued distributions 
# sign., but not a problem (no underdispersion, to few outliers)
testOutliers(sim_fmp_own, type = "bootstrap")
```

3) the tenants' sample
```{r robpoisten, , echo=TRUE, cache = TRUE, warning=FALSE}
# fit poisson regression to each imputed data set 
pois_multiimp_ten <- with(KARE_MI, 
                          glm(numadmeas ~ R104 + logR109 + rich + R71 +        # generic capacity
                                R91 + R92 +
                                R90_1 + R90_5 +
                                R9 + R18 + R4a5 + R75 +    # flood-specific capacity
                                R63_6 + R80a_1 + R63_1 +
                                R63_3 + R63_2 + R63_4 +
                                R97 + R98 + R99 + R106 +   # CVs: gender, age, mig, hhsize
                                R69 + R70 +                # CVs: house
                                Modus,                     # Survey design
                              family = 'poisson',
                              subset = (R7 == "Miete")))

# calculate cluster-robust AME
marginal_pois_ten <- avg_slopes(pois_multiimp_ten, vcov = ~town)
marginal_pois_ten$order <- c(34, 35, 1, 2, 30, 14, 15, 16, 17, 18, 23, 
                             25, 24, 26, 21, 32, 31, 33, 6, 19, 20, 22, 13, 
                             11, 12, 8, 10, 9, 27, 28, 29, 3, 4, 5)  
marginal_pois_ten <- marginal_pois_ten %>%
        mutate(across(c(3:5, 10:13), round, 4))
print(marginal_pois_ten[order(marginal_pois_ten$order, decreasing = F),], nrows = 40, style = "tinytable") 


### Goodness of fit measures
# R^2
Nagelkerke_pois_ten <- numeric(30)
for (i in 1:30) {
  Nagelkerke_pois_ten_res <- c(DescTools::PseudoR2(pois_multiimp_ten$analyses[[i]], which = "Nagelkerke"))
  Nagelkerke_pois_ten[i] <- Nagelkerke_pois_ten_res
}
median(Nagelkerke_pois_ten)

# BIC
BIC_pois_ten <- numeric(30)
for (i in 1:30) {
  BIC_pois_ten_res <- c(BIC(pois_multiimp_ten$analyses[[i]]))
  BIC_pois_ten[i] <- BIC_pois_ten_res
}
median(BIC_pois_ten)
```

Check if logistic regression assumptions are met
```{r robpoistenassumptions, , echo=TRUE, cache = TRUE}
### Test Assumptions with residual diagnostics
sim_fmp_ten <- simulateResiduals(pois_multiimp_ten$analyses[[16]], nSim = 1000) 

# under- and overdispersion --> not sign.
testDispersion(sim_fmp_ten)


# Zero inflation --> not sign.
testZeroInflation(sim_fmp_ten)

# Heteroscedasticity --> not sign.
testQuantiles(sim_fmp_ten)

# KS test for correct distribution of residuals --> not sign.
testUniformity(sim_fmp_ten)

# test if outliers are a concern, bootstrap for integer-valued distributions --> not sign.
testOutliers(sim_fmp_ten, type = "bootstrap")
```

 <!-- get rid of white space at the end of the page -->
<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>
